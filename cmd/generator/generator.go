package main

import (
	"flag"
	"fmt"
	"go/importer"
	"html/template"
	"log"
	"os"
	"strings"
)

var tmplStr = `

// {{.Name}} writes a response to the Responder with the status http.Status{{.Name}}.
func (r *Responder) {{.Name}}() {r.write(http.Status{{.Name}})}

`

var tmplTestStr = `

func TestResponder{{.Name}}(t *testing.T) {
	w := httptest.NewRecorder()
	actual := NewResponder(w)
	actual.{{.Name}}()
	assert.Equal(t, http.Status{{.Name}}, w.Code)
}

`

func main() {
	outDir := flag.String("out-dir", "", "directory to write output to")
	flag.Parse()

	pkgHTTP, err := importer.Default().Import("net/http")
	if err != nil {
		log.Fatal(err)
		return
	}

	tmpl, err := template.New("helper").Parse(tmplStr)
	if err != nil {
		log.Fatal(err)
	}

	tmplT, err := template.New("helpertest").Parse(tmplTestStr)
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create(fmt.Sprintf("%s/helpers.go", *outDir))
	if err != nil {
		log.Fatalf("creating file %+v", err)
	}
	defer f.Close()

	tf, err := os.Create(fmt.Sprintf("%s/helpers_test.go", *outDir))
	if err != nil {
		log.Fatalf("creating test file %+v", err)
	}
	defer tf.Close()

	f.WriteString("// this file is generated by go generate ... do not modify\n")
	f.WriteString("package apiresponse\n")
	tf.WriteString("// this file is generated by go generate ... do not modify\n")
	tf.WriteString("package apiresponse\n")

	for _, name := range pkgHTTP.Scope().Names() {
		if strings.HasPrefix(name, "Status") {
			strippedName := strings.SplitAfter(name, "Status")[1]
			// skip the StatusText method
			if strippedName == "Text" {
				continue
			}

			err := tmpl.Execute(f, struct{ Name string }{Name: strippedName})
			if err != nil {
				log.Fatal(err)
			}

			err = tmplT.Execute(tf, struct{ Name string }{Name: strippedName})
			if err != nil {
				log.Fatal(err)
			}
		}
	}

}
